// Instructions:
// (1) download Fiji
// (2) update Fiji
// (3) run this with something like:
//     /path/to/fiji-linux64 --headless /path/to/isbi2012-cli.bsh true.tif pred.tif

import trainableSegmentation.metrics.*;
import ij.IJ;
import ij.ImagePlus;

if( bsh.args.length != 2)
{
    print("Error: wrong number of arguments!\n");
    print("Usage: /path/to/fiji-linux64 --headless true.tif pred.tif");
    return;
}

originalLabels = new ImagePlus(bsh.args[0]);
proposedLabels = new ImagePlus(bsh.args[1]);

calculatePixelError = new Boolean(true);
calculateRandError = new Boolean(true);
calculateWarpingError = new Boolean(true);

IJ.log("---");
IJ.log("Evaluating segmentation...");
IJ.log("  Original labels: " + originalLabels.getTitle());
IJ.log("  Proposed labels: " + proposedLabels.getTitle() + "\n");

// Calculate segmentation error with the selected metrics
if( calculatePixelError )
{
    IJ.log("\nCalculating pixel error...");
    metric = new PixelError( originalLabels, proposedLabels );
    maxFScore = metric.getPixelErrorMaximalFScore( 0.0, 1.0, 0.1 );
    IJ.log("  Minimum pixel error: " + (1.0 - maxFScore) );
}

if( calculateRandError )
{
    IJ.log("\nCalculating maximal F-score of Rand index...");
    metric = new RandError( originalLabels, proposedLabels );
    maxFScore = metric.getRandIndexMaximalFScore( 0.0, 1.0, 0.05 );
    IJ.log("  Minimum Rand error: " + (1.0 - maxFScore) );
}


if( calculateWarpingError )
{
    IJ.log("\nCalculating warping error by minimizing splits and mergers...");
    metric = new WarpingError( originalLabels, proposedLabels );
    warpingError = metric.getMinimumSplitsAndMergersErrorValue( 0.0, 0.9, 0.1, false, 20 );
    IJ.log("  Minimum warping error: " + warpingError);
    IJ.log("  # errors (splits + mergers pixels) = " + Math.round(warpingError * originalLabels.getWidth() * originalLabels.getHeight() * originalLabels.getImageStackSize() ) );
}
